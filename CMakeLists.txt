PROJECT(MIBDV)
CMAKE_MINIMUM_REQUIRED(VERSION 3.12.0)
INCLUDE(CheckCXXCompilerFlag)

# variabili di configurazione
SET(MIBDV_VERSION 0.1)
SET(ORGANIZATION "DV")
SET(LOG_PATH ${ORGANIZATION}/${PROJECT_NAME}/logs)
STRING(TOLOWER ${PROJECT_NAME} PROJECT_NAME_LOW)
SET(PROGRAM_NAMESPACE ${PROJECT_NAME_LOW})
SET(STYLESHEET_PATH "${PROJECT_SOURCE_DIR}/gui/resources/qss") # solo per sviluppo

IF (CMAKE_HOST_WIN32)
    SET(SPOOL_PATH_DFLT "$ENV{USERPROFILE}")
ELSEIF(CMAKE_HOST_UNIX)
    SET(SPOOL_PATH_DFLT "$ENV{HOME}")
ENDIF()
FILE(TO_CMAKE_PATH ${SPOOL_PATH_DFLT} SPOOL_PATH_DFLT)
STRING(REPLACE "/" "//" SPOOL_PATH_DFLT ${SPOOL_PATH_DFLT}) # aggiungo double quote (consigliato da documentazione cmake)
MESSAGE("SPOOL_PATH: ${SPOOL_PATH_DFLT}")

# variabili di impostazione ambiente
SET(FLAG_DEBUG_OPTION CACHE BOOL "Modalita' debug")
SET(FLAG_CN_PRESENT CACHE BOOL "CN presente")
SET(FLAG_PLC_PRESENT CACHE BOOL "PLC presente")
SET(FLAG_SCANNER_HEAD_PRESENT CACHE BOOL "Testa scansione presente")
SET(FLAG_IPG_YLPN_LASER_PRESENT CACHE BOOL "Laser Ipg YLPN presente")

IF (CMAKE_SIZEOF_VOID_P EQUAL 8)
    SET(ARCHITECTURE "x64")
ELSEIF(CMAKE_SIZEOF_VOID_P EQUAL 4)
    SET(ARCHITECTURE "x86")
ENDIF()
MESSAGE("ARCHITECTURE: ${ARCHITECTURE}")

IF (CMAKE_SIZEOF_VOID_P EQUAL 8)
    SET(ARCHITECTURE "x64")
ELSEIF(CMAKE_SIZEOF_VOID_P EQUAL 4)
    SET(ARCHITECTURE "x86")
ENDIF()
MESSAGE("ARCHITECTURE: ${ARCHITECTURE}")

IF(FLAG_DEBUG_OPTION)
    ADD_DEFINITIONS(-DFLAG_DEBUG)
ELSE()
    REMOVE_DEFINITIONS(-DFLAG_DEBUG)
ENDIF()
IF(FLAG_CN_PRESENT)
    ADD_DEFINITIONS(-DFLAG_CN_PRESENT)
ELSE()
    REMOVE_DEFINITIONS(-DFLAG_CN_PRESENT)
ENDIF()
IF(FLAG_PLC_PRESENT)
    ADD_DEFINITIONS(-DFLAG_PLC_PRESENT)
ELSE()
    REMOVE_DEFINITIONS(-DFLAG_PLC_PRESENT)
ENDIF()
IF(FLAG_SCANNER_HEAD_PRESENT)
    ADD_DEFINITIONS(-DFLAG_SCANNER_HEAD_PRESENT)
ELSE()
    REMOVE_DEFINITIONS(-DFLAG_SCANNER_HEAD_PRESENT)
ENDIF()
IF(FLAG_IPG_YLPN_LASER_PRESENT)
    ADD_DEFINITIONS(-DFLAG_IPG_YLPN_LASER_PRESENT)
ELSE()
    REMOVE_DEFINITIONS(-DFLAG_IPG_YLPN_LASER_PRESENT)
ENDIF()

CHECK_CXX_COMPILER_FLAG("-std=c++14" COMPILER_SUPPORTS_CXX14)
IF(COMPILER_SUPPORTS_CXX14)
  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14")
  SET(CMAKE_CXX_STANDARD 14)
ENDIF()

IF (NOT MSVC)
    #SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wno-reorder -Wno-long-long -pedantic -Wno-comment -fPIC")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wno-missing-noreturn -Wno-reorder -Wno-long-long -pedantic -Wno-comment")
ENDIF(NOT MSVC)
SET(CMAKE_VERBOSE_MAKEFILE TRUE)
SET(CMAKE_INCLUDE_CURRENT_DIR ON)

#FIND_PACKAGE(TIFF REQUIRED)
#MESSAGE("TIFF_LIBRARIES = ${TIFF_LIBRARIES}")

FIND_PACKAGE(Qt5Widgets REQUIRED)
MESSAGE("Qt5Widgets_INCLUDE_DIRS: ${Qt5Widgets_INCLUDE_DIRS}")

FIND_PACKAGE(Qt5Gui REQUIRED)
MESSAGE("Qt5Gui_INCLUDE_DIRS: ${Qt5Gui_INCLUDE_DIRS}")

FIND_PACKAGE(Qt5Core REQUIRED)
MESSAGE("Qt5Core_INCLUDE_DIRS: ${Qt5Core_INCLUDE_DIRS}")

FIND_PACKAGE(Qt5Network REQUIRED)
MESSAGE("Qt5Network_INCLUDE_DIRS: ${Qt5Network_INCLUDE_DIRS}")

FIND_PACKAGE(Qt5LinguistTools REQUIRED)

MESSAGE ("Qt5Widgets_VERSION: ${Qt5Widgets_VERSION}")
MESSAGE ("Qt5Widgets_LIBRARIES: ${Qt5Widgets_LIBRARIES}")
MESSAGE ("Qt5Widgets_INCLUDE_DIRS: ${Qt5Widgets_INCLUDE_DIRS}")
MESSAGE ("Qt5Widgets_DEFINITIONS: ${Qt5Widgets_DEFINITIONS}")
MESSAGE ("Qt5Widgets_COMPILE_DEFINITIONS: ${Qt5Widgets_COMPILE_DEFINITIONS}")
MESSAGE ("Qt5Widgets_FOUND: ${Qt5Widgets_FOUND}")
MESSAGE ("Qt5Widgets_EXECUTABLE_COMPILE_FLAGS: ${Qt5Widgets_EXECUTABLE_COMPILE_FLAGS}")

SET (THIRD_PARTY_PATH "${PROJECT_SOURCE_DIR}/third-party")
MESSAGE("THIRD_PARTY_PATH: ${THIRD_PARTY_PATH}")


######## GALIL #############

SET(GALIL_GCLIB_INSTALLATION_PATH CACHE STRING "Path installazione libreria Galil gclib")
SET(GALIL_GCLIB_INSTALLATION_PATH_DFLT "C:\\Program Files (x86)\\Galil\\gclib")
MESSAGE("GALIL_GCLIB_INSTALLATION_PATH: ${GALIL_GCLIB_INSTALLATION_PATH}")
MESSAGE("GALIL_GCLIB_INSTALLATION_PATH_DFLT: ${GALIL_GCLIB_INSTALLATION_PATH_DFLT}")

FIND_PATH(GALIL_GCLIB_HEADERS_PATH "gclib.h"
    HINTS ${GALIL_GCLIB_INSTALLATION_PATH_DFLT}
    PATHS ${GALIL_GCLIB_INSTALLATION_PATH}
    PATH_SUFFIXES "include")
IF (NOT GALIL_GCLIB_HEADERS_PATH)
    MESSAGE(SEND_ERROR "GALIL GCLIB HEADERS NOT FOUND")
ENDIF()
INCLUDE_DIRECTORIES(${GALIL_GCLIB_HEADERS_PATH})

FIND_LIBRARY(GALIL_GCLIB_GCLIB "gclib"
    HINTS ${GALIL_GCLIB_INSTALLATION_PATH_DFLT}
    PATHS ${GALIL_GCLIB_INSTALLATION_PATH}
    PATH_SUFFIXES "lib/dynamic/${ARCHITECTURE}")
IF (NOT GALIL_GCLIB_GCLIB)
    MESSAGE(SEND_ERROR "GALIL GCLIB GCLIB NOT FOUND")
ENDIF()

FIND_LIBRARY(GALIL_GCLIB_GCLIBO "gclibo"
    HINTS ${GALIL_GCLIB_INSTALLATION_PATH_DFLT}
    PATHS ${GALIL_GCLIB_INSTALLATION_PATH}
    PATH_SUFFIXES "lib/dynamic/${ARCHITECTURE}")
IF (NOT GALIL_GCLIB_GCLIBO)
    MESSAGE(SEND_ERROR "GALIL GCLIB GCLIBO NOT FOUND")
ENDIF()

FIND_FILE(GALIL_GCLIB_GCLIB_DLL "gclib.dll"
    HINTS ${GALIL_GCLIB_INSTALLATION_PATH_DFLT}
    PATHS ${GALIL_GCLIB_INSTALLATION_PATH}
    PATH_SUFFIXES "dll/${ARCHITECTURE}")
IF (NOT GALIL_GCLIB_GCLIB_DLL)
    MESSAGE(SEND_ERROR "GALIL GCLIB GCLIB DLL NOT FOUND")
ENDIF()

FIND_FILE(GALIL_GCLIB_GCLIBO_DLL "gclibo.dll"
    HINTS ${GALIL_GCLIB_INSTALLATION_PATH_DFLT}
    PATHS ${GALIL_GCLIB_INSTALLATION_PATH}
    PATH_SUFFIXES "dll/${ARCHITECTURE}")
IF (NOT GALIL_GCLIB_GCLIBO_DLL)
    MESSAGE(SEND_ERROR "GALIL GCLIB GCLIBO DLL NOT FOUND")
ENDIF()

SET(GALIL_LIBRARIES ${GALIL_GCLIB_GCLIB} ${GALIL_GCLIB_GCLIBO})

MESSAGE("GALIL_GCLIB_HEADERS_PATH: ${GALIL_GCLIB_HEADERS_PATH}")
MESSAGE("GALIL_GCLIB_GCLIB: ${GALIL_GCLIB_GCLIB}")
MESSAGE("GALIL_GCLIB_GCLIBO: ${GALIL_GCLIB_GCLIBO}")
MESSAGE("GALIL_GCLIB_GCLIB_DLL: ${GALIL_GCLIB_GCLIB_DLL}")
MESSAGE("GALIL_GCLIB_GCLIBO_DLL: ${GALIL_GCLIB_GCLIBO_DLL}")
MESSAGE("GALIL_LIBRARIES: ${GALIL_LIBRARIES}")


######## INIZIO IPG MARKING LIBRARY WRAPPER #############

SET(IPG_MARKING_LIBRARY_WRAPPER_PATH "${THIRD_PARTY_PATH}/ipg-marking-library-wrapper")
MESSAGE("IPG_MARKING_LIBRARY_WRAPPER_PATH: ${IPG_MARKING_LIBRARY_WRAPPER_PATH}")

FIND_PATH(IPG_MARKING_LIBRARY_WRAPPER_HEADERS_PATH "Scanner.h"
    PATHS ${IPG_MARKING_LIBRARY_WRAPPER_PATH}
    PATH_SUFFIXES "include")
IF (NOT IPG_MARKING_LIBRARY_WRAPPER_HEADERS_PATH)
    MESSAGE(SEND_ERROR "IPG MARKING LIBRARY WRAPPER HEADERS NOT FOUND")
ENDIF()
INCLUDE_DIRECTORIES(${IPG_MARKING_LIBRARY_WRAPPER_HEADERS_PATH})

FIND_LIBRARY(IPG_MARKING_LIBRARY_WRAPPER_LIB "ipg-marking-library-wrapper"
    PATHS ${IPG_MARKING_LIBRARY_WRAPPER_PATH}
    PATH_SUFFIXES "lib/x86")
IF (NOT IPG_MARKING_LIBRARY_WRAPPER_LIB)
    MESSAGE(SEND_ERROR "IPG MARKING LIBRARY WRAPPER LIB NOT FOUND")
ENDIF()

FIND_FILE(IPG_MARKING_LIBRARY_WRAPPER_DLL "ipg-marking-library-wrapper.dll"
    PATHS ${IPG_MARKING_LIBRARY_WRAPPER_PATH}
    PATH_SUFFIXES "dll/x86")
IF (NOT IPG_MARKING_LIBRARY_WRAPPER_DLL)
    MESSAGE(SEND_ERROR "IPG MARKING LIBRARY WRAPPER DLL NOT FOUND")
ENDIF()

MESSAGE("IPG_MARKING_LIBRARY_WRAPPER_HEADERS_PATH: ${IPG_MARKING_LIBRARY_WRAPPER_HEADERS_PATH}")
MESSAGE("IPG_MARKING_LIBRARY_WRAPPER_LIB: ${IPG_MARKING_LIBRARY_WRAPPER_LIB}")
MESSAGE("IPG_MARKING_LIBRARY_WRAPPER_DLL: ${IPG_MARKING_LIBRARY_WRAPPER_DLL}")


######## INIZIO IPG MARKING LIBRARY #############

SET(IPG_MARKING_LIBRARY_INSTALLATION_PATH CACHE STRING "Path installazione Ipg Marking Library")
MESSAGE("IPG_MARKING_LIBRARY_INSTALLATION_PATH: ${IPG_MARKING_LIBRARY_INSTALLATION_PATH}")
FIND_FILE(IPG_MARKING_LIBRARY_DLL "IpgMarkingGraphicsLibrary.dll"
    HINTS "C:\\Program Files (x86)\\IPGP\\IpgMarkingGraphicsLibrary"
    PATHS ${IPG_MARKING_LIBRARY_INSTALLATION_PATH})
IF (NOT IPG_MARKING_LIBRARY_DLL)
    MESSAGE(SEND_ERROR "IPG MARKING LIBRARY DLL NOT FOUND")
ENDIF()

MESSAGE("IPG_MARKING_LIBRARY_DLL: ${IPG_MARKING_LIBRARY_DLL}")


##### FINE IPG ######



INCLUDE_DIRECTORIES(${Qt5Core_INCLUDE_DIRS} ${Qt5Widgets_INCLUDE_DIRS} ${Qt5Network_INCLUDE_DIRS})
SET(QT_LIBRARIES ${Qt5Core_LIBRARIES} ${Qt5Widgets_LIBRARIES} ${Qt5Gui_LIBRARIES} ${Qt5Network_LIBRARIES})

SET(CMAKE_AUTOMOC ON)
SET(CMAKE_AUTOUIC ON)
SET(CMAKE_AUTORCC ON)

CONFIGURE_FILE(${PROJECT_SOURCE_DIR}/configure.h.in ${PROJECT_BINARY_DIR}/configure.h)
INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR})

SET(PROJECT_SOURCES "" CACHE INTERNAL "sources of project")
SET(PROJECT_HEADERS "" CACHE INTERNAL "header of project")
SET(PROJECT_UI_FILES "" CACHE INTERNAL "UI files of project")
SET(PROJECT_QSS_FILES "" CACHE INTERNAL "qss stylesheet project")
SET(PROJECT_QRC_FILES "" CACHE INTERNAL "qrc project files")
SET(PROJECT_TS_FILES "" CACHE INTERNAL "ts project files")
SET(PROJECT_QM_FILES "" CACHE INTERNAL "qm project files")
SET(UPDATE_TS CACHE BOOL "") # questo lo setto qui cosi poi lo posso modificare da QtCreator
SET(PROJECT_QSS_PATH "" CACHE INTERNAL "path of qss files") # questo serve per sviluppare il CSS a runtime senza usare il file .qrc (binario)

SET(PROJECT_FOLDERS
    "${PROJECT_SOURCE_DIR}/core"
    "${PROJECT_SOURCE_DIR}/data"
    "${PROJECT_SOURCE_DIR}/common"
    "${PROJECT_SOURCE_DIR}/devices"
    "${PROJECT_SOURCE_DIR}/gui"
)

FOREACH(item ${PROJECT_FOLDERS})
    MESSAGE("Folder: " ${item})
    INCLUDE_DIRECTORIES(${item})
    ADD_SUBDIRECTORY(${item})
ENDFOREACH(item)

MESSAGE("*** PROJECT_SOURCES: ${PROJECT_SOURCES}")
MESSAGE("*** PROJECT_HEADERS: ${PROJECT_HEADERS}")
MESSAGE("*** PROJECT_UI_FILES: ${PROJECT_UI_FILES}")
MESSAGE("*** PROJECT_QSS_FILES: ${PROJECT_QSS_FILES}")
MESSAGE("*** PROJECT_QRC_FILES: ${PROJECT_QRC_FILES}")
MESSAGE("*** PROJECT_TS_FILES: ${PROJECT_TS_FILES}")
MESSAGE("*** PROJECT_QM_FILES: ${PROJECT_QM_FILES}")

MESSAGE("LINK_LIBRARIES: ${QT_LIBRARIES} ${GALIL_LIBRARIES} ${IPG_MARKING_LIBRARY_WRAPPER_LIB}")

IF(UPDATE_TS)

    MESSAGE("QT5_CREATE_TRANSLATION")
    FOREACH(TS_ITEM ${PROJECT_TS_FILES})
        QT5_CREATE_TRANSLATION(${PROJECT_SOURCES} ${PROJECT_HEADERS} ${PROJECT_UI_FILES} main.cpp ${TS_ITEM})
    ENDFOREACH(TS_ITEM)

    #SET(PROJECT_QRC_FILES "") # questo serve per evitare problemi di compilazione RCC con CMAKE_AUTORCC ON

ELSE(UPDATE_TS)

    MESSAGE("QT5_ADD_TRANSLATION")
    FOREACH(QM_ITEM ${PROJECT_QM_FILES})
        QT5_ADD_TRANSLATION(${QM_ITEM} ${PROJECT_TS_FILES})
    ENDFOREACH(QM_ITEM)

ENDIF(UPDATE_TS)

if ( MSVC )
    FOREACH( OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES} )
        STRING( TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG )
        SET( CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_CURRENT_BINARY_DIR} )
        SET( CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_CURRENT_BINARY_DIR} )
        SET( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_CURRENT_BINARY_DIR} )
    ENDFOREACH( OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES )
ENDIF ( MSVC )

ADD_EXECUTABLE(${PROJECT_NAME}-${MIBDV_VERSION}
    main.cpp
    ${PROJECT_SOURCES}
    ${PROJECT_HEADERS}
    ${PROJECT_UI_FILES}
    ${PROJECT_QSS_FILES}
    ${PROJECT_QM_FILES}
    ${PROJECT_QRC_FILES}
    ${PROJECT_TS_FILES}
    )

TARGET_LINK_LIBRARIES(${PROJECT_NAME}-${MIBDV_VERSION}
    ${QT_LIBRARIES}
    ${GALIL_LIBRARIES}
    ${IPG_MARKING_LIBRARY_WRAPPER_LIB}
    )

IF(MSVC_IDE)
    INSTALL(TARGETS ${PROJECT} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/\${BUILD_TYPE})
ENDIF(MSVC_IDE)

FOREACH(QM_ITEM ${PROJECT_QM_FILES})
    ADD_CUSTOM_COMMAND(
        TARGET ${PROJECT_NAME}-${LIFE_VERSION}
        PRE_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy "${PROJECT_BINARY_DIR}/${QM_ITEM}" "${PROJECT_SOURCE_DIR}/ui/lang/${QM_ITEM}"
        )
ENDFOREACH(QM_ITEM)


# QUI COPIO LE DLL NELLA BUILD PATH
ADD_CUSTOM_COMMAND(TARGET ${PROJECT_NAME}-${MIBDV_VERSION}
    POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy ${GALIL_GCLIB_GCLIB_DLL} ${CMAKE_CURRENT_BINARY_DIR}
    COMMAND ${CMAKE_COMMAND} -E copy ${GALIL_GCLIB_GCLIBO_DLL} ${CMAKE_CURRENT_BINARY_DIR}
    COMMAND ${CMAKE_COMMAND} -E copy ${IPG_MARKING_LIBRARY_WRAPPER_DLL} ${CMAKE_CURRENT_BINARY_DIR}
    COMMAND ${CMAKE_COMMAND} -E copy ${IPG_MARKING_LIBRARY_DLL} ${CMAKE_CURRENT_BINARY_DIR}
    )

FOREACH (DLL_ITEM ${QT_LIBRARIES})
    IF (${CMAKE_BUILD_TYPE} STREQUAL "Debug")
        GET_TARGET_PROPERTY(_loc ${DLL_ITEM} LOCATION_DEBUG)
    ELSE()
        GET_TARGET_PROPERTY(_loc ${DLL_ITEM} LOCATION)
    ENDIF()
    MESSAGE("Plugin ${DLL_ITEM} is at location ${_loc}")
    ADD_CUSTOM_COMMAND(TARGET ${PROJECT_NAME}-${MIBDV_VERSION}
        POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy ${_loc} ${CMAKE_CURRENT_BINARY_DIR})
ENDFOREACH(DLL_ITEM)
